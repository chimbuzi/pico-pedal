# pico-pedal
Very much work-in-progress.

# High-level architecture

At a very high level, samples are read in from an ADC via the SPI bus, are processed, and are then output again. I may add hardware design documents at some point (gerbers, schematics, BoM etc).

## Multicore features

There isn't sufficient processing power on this thing to be able to do any interesting FX processing with a single core. So we dedicate one core to handling I/O and the other core to doing FX processing. The cores communicate using the built-in FIFOs, and use these for sync.

We add an additional sample of latency here on purpose; the I/O core always commits a read before a write, but the write is for the sample from the previous cycle. By ensuring the I/O core always reads one sample ahead and writes one sample behind we ensure that one core only blocks on the other when it has completed its task ahead of its deadline.

The scheduling deadline is enfoced using a repeating alarm. This alarm goes off every 1/44100 th of a second, and triggers a RW pair from the I/O core. If the FX core has completed its task ahead of the deadline, it will block on the FIFO for the next sample from the I/O core. The I/O core will block on the FX core when waiting for a sample and on the repeating alarm before a RW cycle.

Deadlines are not enforced rigidly; if one sample is missed due to an execution overrun, the next sample will also be intentionally missed. If deadlines are repeatedly missed, I think things will get pretty ugly pretty quickly and it will probably just crap its pants and lock up.

# List of FX currently supported

## Distortion/overdrive

This is a very simple implementation of clip distortion. If a sample `s` has a value such that `if (abs(s) > t) s = t * sign(s);`. Setting `t` to be smaller means more distortion, but has the side effect of lower output volume. Without storing more samples, re-normalising the signal isn't possible. It may help to pass the output signal through a compressor.

Because we're doing naive clipping (unlike the slightly rounded-off signal an analogue distortion would give) it will make the sound a lot less harsh if some mild reverb and an LPF are used after this effect.

## Fuzz

This is similar to the clip distortion, but is implemented such that any sample *larger* than the threshold is pinned to the max/min values. Has the side-effect that the output is always loud; adding some ramp up and down (as per analogue fuzz) could help here.

Fuzzers usually have a lot of high harmonics, but even so rolling off the top end can help here too.


## Tremolo

This is dead simple. A sine of selectable wavelength is used to modulate the audio. I experimented with a static sine hard-coded in a header file (took too much flash), a pre-generated sine which is generated when the effect is selected (took too much RAM for slow tremolo), and generated on the fly. The latter option has the largest processing overhead, but is just about doable. Does have continuity issues when changing the trmolo speed.

## Octaver

This is the first effect which introduces more than a single sample of latency in software. Here, we capture a short buffer during one time period. Then we capture a second buffer while playing back the first. If we want to shift up an octave, we play back every other sample in the buffer, and therefore play the buffer back twice while capturing the next one (double the frequency = up an octave). If we want to shift down an octave, we only play back the first half of the buffer, and play each sample twice in a row.

This kinda works, but has the issue of sample matching at the boundaries between buffers - testing suggestst that actually the high harmonics generated by discontinuities between samples dominates over the fundamental of the input audio. If you think you can improve this, please submit a pull request!

I'd like to try rewriting this based on a more traditional 'analogue' octaver, whereby we gate out the fundamental and use the zero-crossings to invert alternate peaks. This looks like it would be too complex to be able to handle with just one core for processing, so I'd have to redo the architecture a bit. For the TODO list.

## Delay

This is pretty trivial. Capture a buffer, then play it back after a predetermined delay. Delay length severely limited by available memory.

## Reverb

Also pretty trivial. Pass through the input as-is, then keep a couple of different buffers of varying lengths; output the sum of these buffers and the dry audio in a pleasing ratio. Also very limited by available RAM.


# Known issues

* Octaver is shockingly bad.
